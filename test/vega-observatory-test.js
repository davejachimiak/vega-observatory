// Generated by CoffeeScript 1.7.1
(function() {
  describe('VegaObservatory', function() {
    beforeEach(function() {
      var options;
      window.RTCSessionDescription = (function() {
        function RTCSessionDescription() {}

        return RTCSessionDescription;

      })();
      window.RTCIceCandidate = (function() {
        function RTCIceCandidate() {}

        return RTCIceCandidate;

      })();
      this.peerConnectionConfig = new Object;
      this.peerConnectionFactory = {
        create: function() {}
      };
      this.peerStore = {
        add: function() {},
        addStream: function() {},
        remove: function() {},
        find: function() {},
        on: function() {}
      };
      this.sessionDescriptionCreator = {
        forOffer: function() {},
        forAnswer: function() {}
      };
      this.webRTCInterop = {
        infectGlobal: (function(_this) {
          return function() {
            return _this.webRTCInteropEngaged = true;
          };
        })(this)
      };
      options = {
        url: 'ws://0.0.0.0:3000',
        roomId: '/abc123',
        badge: {},
        peerStore: this.peerStore,
        webRTCInterop: this.webRTCInterop,
        peerConnectionConfig: this.peerConnectionConfig,
        peerConnectionFactory: this.peerConnectionFactory,
        sessionDescriptionCreator: this.sessionDescriptionCreator
      };
      this.vegaObservatory = new VegaObservatory(options);
      return this.vegaClient = this.vegaObservatory.vegaClient;
    });
    afterEach(function() {
      return sinon.collection.restore();
    });
    it('infects the w3c global names with vendor prefixes for interoperability', function() {
      return expect(this.webRTCInteropEngaged).to.be["true"];
    });
    describe('#call', function() {
      return it('delegates to the vega client', function() {
        var call;
        call = sinon.collection.stub(this.vegaClient, 'call');
        this.vegaObservatory.call();
        return expect(call).to.have.been.called;
      });
    });
    describe('#sendOffer', function() {
      return it('delegates to the vega client', function() {
        var offer, peerId, theOffer;
        theOffer = new Object;
        peerId = 'peerId';
        offer = sinon.collection.stub(this.vegaClient, 'offer');
        this.vegaObservatory.sendOffer(theOffer, peerId);
        return expect(offer).to.have.been.calledWith(theOffer, peerId);
      });
    });
    describe('#sendAnswer', function() {
      return it('delegates to the vega client', function() {
        var answer, peerId, theAnswer;
        theAnswer = new Object;
        peerId = 'peerId';
        answer = sinon.collection.stub(this.vegaClient, 'answer');
        this.vegaObservatory.sendAnswer(theAnswer, peerId);
        return expect(answer).to.have.been.calledWith(theAnswer, peerId);
      });
    });
    describe('#hangUp', function() {
      return it('sends a hangUp message to the vega client', function() {
        var hangUp;
        hangUp = sinon.collection.stub(this.vegaClient, 'hangUp');
        this.vegaObservatory.hangUp();
        return expect(hangUp).to.have.been.called;
      });
    });
    describe('#sendCandidate', function() {
      return it('delegates to the vega client', function() {
        var candidate, peerId, theCandidate;
        theCandidate = new Object;
        peerId = 'peerId';
        candidate = sinon.collection.stub(this.vegaClient, 'candidate');
        this.vegaObservatory.sendCandidate(theCandidate, peerId);
        return expect(candidate).to.have.been.calledWith(theCandidate, peerId);
      });
    });
    describe('#createOffer', function() {
      return it('creates an offer on the peer connection with success and failure callbacks', function() {
        var forOffer;
        this.peerId = 'peerId';
        this.peerConnection = new Object;
        this.peer = {
          peerId: this.peerId,
          badge: {
            name: 'Dave'
          },
          peerConnection: this.peerConnection
        };
        sinon.collection.stub(this.peerStore, 'find').withArgs(this.peerId).returns(this.peer);
        forOffer = sinon.collection.stub(this.sessionDescriptionCreator, 'forOffer');
        this.vegaObservatory.createOffer(this.peerId);
        return expect(forOffer).to.have.been.calledWith(this.vegaObservatory, this.peerId, this.peerConnection);
      });
    });
    describe('#createAnswer', function() {
      return it('creates a session description for an answer', function() {
        var forAnswer;
        this.peerId = 'peerId';
        this.peerConnection = new Object;
        this.peer = {
          peerId: this.peerId,
          badge: {
            name: 'Dave'
          },
          peerConnection: this.peerConnection
        };
        sinon.collection.stub(this.peerStore, 'find').withArgs(this.peerId).returns(this.peer);
        forAnswer = sinon.collection.stub(this.sessionDescriptionCreator, 'forAnswer');
        this.vegaObservatory.createAnswer(this.peerId);
        return expect(forAnswer).to.have.been.calledWith(this.vegaObservatory, this.peerId, this.peerConnection);
      });
    });
    describe('#onStreamAdded', function() {
      return it('sets a callback on the streamAdded event on the store', function() {
        var f, oN;
        oN = sinon.collection.stub(this.peerStore, 'on');
        f = function() {};
        this.vegaObservatory.onStreamAdded(f);
        return expect(oN).to.have.been.calledWith('streamAdded', f);
      });
    });
    describe('#onPeerRemoved', function() {
      return it('sets a callback on the remove event on the store', function() {
        var f, oN;
        oN = sinon.collection.stub(this.peerStore, 'on');
        f = function() {};
        this.vegaObservatory.onPeerRemoved(f);
        return expect(oN).to.have.been.calledWith('remove', f);
      });
    });
    return describe('vega client callbacks', function() {
      beforeEach(function() {
        this.peerConnection = {
          setRemoteDescription: function() {},
          poop: 'poop'
        };
        return this.createPeerConnection = sinon.collection.stub(this.peerConnectionFactory, 'create');
      });
      describe('on callAccepted', function() {
        beforeEach(function() {
          this.peer1 = {
            peerId: 'peerId1',
            badge: {
              name: 'Dave'
            }
          };
          this.peer2 = {
            peerId: 'peerId2',
            badge: {
              name: 'Allie'
            }
          };
          this.peers = [this.peer1, this.peer2];
          return this.peers.forEach((function(_this) {
            return function(peer) {
              return _this.createPeerConnection.withArgs(_this.vegaObservatory, peer, _this.peerConnectionConfig).returns(_this.peerConnection);
            };
          })(this));
        });
        it('saves references to all peers in the response', function() {
          var add;
          add = sinon.collection.spy(this.peerStore, 'add');
          this.vegaClient.trigger('callAccepted', this.peers);
          return this.peers.forEach((function(_this) {
            return function(peer) {
              return expect(add).to.have.been.calledWith(peer);
            };
          })(this));
        });
        return it('triggers a callAccepted event on the observatory', function() {
          var object;
          object = {};
          this.vegaObservatory.on('callAccepted', function(payload) {
            return object.peers = payload;
          });
          this.vegaClient.trigger('callAccepted', this.peers);
          return expect(object.peers).to.eq(this.peers);
        });
      });
      describe('on offer', function() {
        beforeEach(function() {
          var offer, peer;
          this.badge = {
            name: 'Dave'
          };
          this.peerId = 'peerId';
          peer = {
            peerId: this.peerId,
            badge: this.badge
          };
          this.payload = peer;
          offer = {
            'offer key': 'offer value'
          };
          this.payload.offer = offer;
          this.createPeerConnection.withArgs(this.vegaObservatory, peer, this.peerConnectionConfig).returns(this.peerConnection);
          this.setRemoteDescription = sinon.collection.stub(this.peerConnection, 'setRemoteDescription');
          return this.rtcSessionDescription = sinon.createStubInstance(window.RTCSessionDescription);
        });
        it('adds the peer to the peer store', function() {
          var add;
          add = sinon.collection.spy(this.peerStore, 'add');
          this.vegaClient.trigger('offer', this.payload);
          return expect(add).to.have.been.calledWithMatch({
            peerId: this.peerId,
            badge: this.badge,
            peerConnection: this.peerConnection
          });
        });
        it('sets the offer on the peer connection via session description', function() {
          this.vegaClient.trigger('offer', this.payload);
          return expect(this.setRemoteDescription).to.have.been.calledWith(this.rtcSessionDescription);
        });
        return it('triggers an offer event', function() {
          var object;
          object = {};
          this.vegaObservatory.on('offer', function(payload) {
            return object.payload = payload;
          });
          this.vegaClient.trigger('offer', this.payload);
          return expect(object.payload).to.eq(this.payload);
        });
      });
      describe('on answer', function() {
        beforeEach(function() {
          this.peerId = 'peerId';
          this.badge = {
            name: 'Dave'
          };
          this.peer = {
            peerId: this.peerId,
            badge: this.badge,
            peerConnection: this.peerConnection
          };
          sinon.collection.stub(this.peerStore, 'find').withArgs(this.peerId).returns(this.peer);
          this.setRemoteDescription = sinon.collection.stub(this.peerConnection, 'setRemoteDescription');
          this.rtcSessionDescription = sinon.createStubInstance(window.RTCSessionDescription);
          return this.payload = {
            answer: {
              an: 'answer'
            },
            peerId: this.peerId
          };
        });
        it('sets the answer on the peer connection via session description', function() {
          this.vegaClient.trigger('answer', this.payload);
          return expect(this.setRemoteDescription).to.have.been.calledWith(this.rtcSessionDescription);
        });
        return it('triggers an answer event', function() {
          var object;
          object = {};
          this.vegaObservatory.on('answer', function(payload) {
            return object.payload = payload;
          });
          this.vegaClient.trigger('answer', this.payload);
          return expect(object.payload).to.eq(this.payload);
        });
      });
      describe('on candidate', function() {
        beforeEach(function() {
          this.peerConnection = {
            addIceCandidate: function() {}
          };
          this.badge = {
            name: 'Dave'
          };
          this.peerId = 'peerId';
          this.peer = {
            peerId: this.peerId,
            badge: this.badge,
            peerConnection: this.peerConnection
          };
          sinon.collection.stub(this.peerStore, 'find').withArgs(this.peerId).returns(this.peer);
          this.addIceCandidate = sinon.collection.stub(this.peerConnection, 'addIceCandidate');
          this.rtcIceCandidate = sinon.createStubInstance(window.RTCIceCandidate);
          return this.payload = {
            candidate: {
              an: 'candidate'
            },
            peerId: this.peerId
          };
        });
        it('adds the ice candidate to the proper peer connection', function() {
          this.vegaClient.trigger('candidate', this.payload);
          return expect(this.addIceCandidate).to.have.been.calledWith(this.rtcIceCandidate);
        });
        return it('triggers a candidate event with the payload', function() {
          var object;
          object = {};
          this.vegaObservatory.on('candidate', function(payload) {
            return object.payload = payload;
          });
          this.vegaClient.trigger('candidate', this.payload);
          return expect(object.payload).to.eq(this.payload);
        });
      });
      return describe('on peerHangUp', function() {
        beforeEach(function() {
          this.badge = {
            name: 'Dave'
          };
          this.peerId = 'peerId';
          this.peer = {
            peerId: this.peerId,
            badge: this.badge,
            peerConnection: this.peerConnection
          };
          return this.payload = {
            peerId: this.peerId
          };
        });
        it('triggers a peerHangUp event', function() {
          var object;
          object = {};
          this.vegaObservatory.on('peerHangUp', function(payload) {
            return object.payload = payload;
          });
          this.vegaClient.trigger('peerHangUp', this.payload);
          return expect(object.payload).to.eq(this.payload);
        });
        return it('removes the peer from the peer store', function() {
          var remove;
          remove = sinon.collection.stub(this.peerStore, 'remove');
          this.vegaClient.trigger('peerHangUp', this.payload);
          return expect(remove).to.have.been.calledWith(this.peerId);
        });
      });
    });
  });

}).call(this);
